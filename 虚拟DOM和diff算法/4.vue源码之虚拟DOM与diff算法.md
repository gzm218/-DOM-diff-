# Vue 源码解析之虚拟 DOM 和 diff 算法

# 看看源码，理解算法，重点记住四命中

### diff 算法

> - diff 算法可以进行精细化对比，实现最小量更新
> - ![cmd-markdown-logo](/img/jingxihua.png)
> - key 是节点的唯一标识,在最小量更新中起到重要作用
> - 只有同一个虚拟节点，才进行精细化比较(选择器相同且 key 相同)
> - 只进行同层比较，不会进行跨层比较,同层比较下的效率最高
> - diff 是发生在虚拟 dom 上的(下图)
> - ![cmd-markdown-logo](/img/虚拟dom.png)
> - ![cmd-markdown-logo](/img/diff计算.png)

# 研究 1 虚假 DOM 如何被渲染函数(h 函数)产生？

- h 函数用来产生虚拟节点(vnode)

```js
//调用h函数
h('a', { props: { href: 'http://www.baidu.com' } }, 'baidu');
//得到虚拟节点
{"sel":"a","data":{props:{href: 'http://www.baidu.com'}},"text":'baidu'}
//表示真正的DOM节点
<a href: 'http://www.baidu.com'>baidu </a>
```

- h 函数可以嵌套(重要)
  ![cmd-markdown-logo](/img/h嵌套.png)
- vnode 属性

```js
{
  children: undefined; // 子元素 数组
  data: {
  } // 属性、样式、key
  elm: undefined; // 对应的真正的dom节点(对象)，undefined表示节点还没有上dom树
  // 唯一标识
  key: sel: ''; // 选择器
  text: ''; // 文本内容
}
```

- 使用 h 函数创建虚拟节点

```js
// 创建虚拟节点
var myVnode1 = h('a', { props: { href: 'https://www.baidu.com' } }, 'algg');
console.log(myVnode1);
```

- 用 patch 函数 将虚拟节点上述 DOM 树

```js
// 创建patch函数
const patch = init([
  classModule,
  propsModule,
  styleModule,
  eventListenersModule,
]);

// 创建虚拟节点
var myVnode1 = h(
  'a',
  { props: { href: 'https://www.baidu.com', target: '_blank' } },
  'algg'
);

// 让虚拟节点上树
let container = document.getElementById('container');
patch(container, myVnode1);
```

# 研究 2 diff 算法原理？

- 原理

  - 最小量更新，key 很关键。key 是这个节点的唯一标识，告诉 diff 算法，在更改前后它们是同一个 DOM 节点。

  - 只是同一个虚拟节点，才进行精细化比较（往 ul 中的 li 添加 li），否则就是暴力删除旧的、插入新的（ul 中的 li 换到在 ol 中去）
  - 问题： 如何定义是同一个虚拟节点
    答：选择器相同且 key 相同
  - 只进行同层比较，不会进行跨层比较。即使是同一片 虚拟节点，但是跨层了，diff 就是暴力删除旧的，然后插入新的

- 四命中（！！！！！！！
  ![cmd-markdown-logo](/img/simingzhong.png)

  - 比较 ① 新前 newStart 与 旧前 oldStart
    如果命中 ① 了，patch 之后就移动头指针 newStart++ oldStart++
    ![cmd-markdown-logo](/img/simingzhong1.png)
    如果没命中就接着比较下一种情况
  - 比较 ② 新后 newEnd 与 旧后 oldEnd
    如果命中 ② 了，patch 后就移动尾指针 newEnd-- oldEnd–
    ![cmd-markdown-logo](/img/simingzhong2.png)
    如果没命中就接着比较下一种情况
  - 比较 ③ 新后 newEnd 与 旧前 oldStart
    如果命中 ③ 了，将 新后 newEnd 指向的节点移动到 旧后 oldEnd 之后
    ![cmd-markdown-logo](/img/simingzhong3.png)
    命中 ③ 复杂情况举例——倒序
    ![cmd-markdown-logo](/img/simingzhong31.png)
    如果没命中就接着比较下一种情况
  - 比较 ④ 新前 newStart 与 旧后 oldEnd
    如果命中 ④ 了，将 新前 newStart 指向的节点，移动到 旧前 oldStart 之前
    ![cmd-markdown-logo](/img/simingzhong4.png)
  - 四种都没命中 遍历 oldVnode 中的 key
    找到了就 移动位置 移动指针 newStart++
    ![cmd-markdown-logo](/img/weizhongming.png)
    没找的就是新节点，直接插入所有未处理旧节点之前

    ```js
    // 四种都没有匹配到，都没有命中
    console.log('四种都没有命中');
    // 寻找 keyMap 一个映射对象， 就不用每次都遍历 old 对象了
    if (!keyMap) {
      keyMap = {};
      // 记录 oldVnode 中的节点出现的 key
      // 从 oldStartIdx 开始到 oldEndIdx 结束，创建 keyMap
      for (let i = oldStartIdx; i <= oldEndIdx; i++) {
        const key = oldCh[i].key;
        if (key !== undefined) {
          keyMap[key] = i;
        }
      }
    }
    console.log(keyMap);
    // 寻找当前项（newStartIdx）在 keyMap 中映射的序号
    const idxInOld = keyMap[newStartVnode.key];
    if (idxInOld === undefined) {
      // 如果 idxInOld 是 undefined 说明是全新的项，要插入
      // 被加入的项（就是 newStartVnode 这项)现不是真正的 DOM 节点
      parentElm.insertBefore(createElement(newStartVnode), oldStartVnode.elm);
    } else {
      // 说明不是全新的项，要移动
      const elmToMove = oldCh[idxInOld];
      patchVnode(elmToMove, newStartVnode);
      // 把这项设置为 undefined，表示我已经处理完这项了
      oldCh[idxInOld] = undefined;
      // 移动，调用 insertBefore 也可以实现移动。
      parentElm.insertBefore(elmToMove.elm, oldStartVnode.elm);
    }
    // newStartIdx++;
    newStartVnode = newCh[++newStartIdx];
    ```

  - 循环结束 - newVnode 还剩
    ![cmd-markdown-logo](/img/newsheng.png)
    ![cmd-markdown-logo](/img/haisheng1.png) - oldVnode 还剩
    ![cmd-markdown-logo](/img/oldsheng.png)
    ![cmd-markdown-logo](/img/oldsheng1.png)
    ![cmd-markdown-logo](/img/oldsheng2.png) -
    ```js
    // 循环结束
    if (newStartIdx <= newEndIdx) {
      // 说明 newVndoe 还有剩余节点没有处理，所以要添加这些节点
      for (let i = newStartIdx; i <= newEndIdx; i++) {
        // insertBefore 方法可以自动识别 null，如果是 null 就会自动排到队尾，和 appendChild 一致
        parentElm.insertBefore(createElement(newCh[i]), oldCh[oldStartIdx].elm);
      }
    } else if (oldStartIdx <= oldEndIdx) {
      // 说明 oldVnode 还有剩余节点没有处理，所以要删除这些节点
      for (let i = oldStartIdx; i <= oldEndIdx; i++) {
        if (oldCh[i]) {
          parentElm.removeChild(oldCh[i].elm);
        }
      }
    }
    ```

# 研究 3 虚拟 DOM 如何通过 diff 变为真正的 DOM 的
